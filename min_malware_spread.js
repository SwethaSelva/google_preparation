class UnionFind {
  constructor (length) {
    this.parent = [...new Array(length).keys()];
    this.rank = new Array(length).fill(1);
  }
  findParent (idx) {
    if (this.parent[idx] === idx) return idx;
    return this.findParent(this.parent[idx]);
  }
  union (idx1, idx2) {
    let parent1 = this.findParent(idx1);
    let parent2 = this.findParent(idx2);
    if (parent1 === parent2) return true;

    if (this.rank[parent1] >= this.rank[parent2]) {
      this.rank[parent1] += this.rank[parent2];
      this.parent[parent2] = parent1;
    } else {
      this.rank[parent2] += this.rank[parent1];
      this.parent[parent1] = parent2;
    }
  }
}
/**
 * https://leetcode.com/problems/minimize-malware-spread/
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
  let uf = new UnionFind(graph.length);

  for (let i = 0; i < graph.length; i++) {
    for (let j = 0; j < graph.length; j++) {
      if (i === j || !graph[i][j]) continue;

      uf.union(i, j);
    }
  }

  let parents = {};
  for (let i = 0; i < initial.length; i++) {
    let parent = uf.findParent(initial[i]);

    if (!parents[parent]) parents[parent] = [];
    parents[parent].push(initial[i]);
  }

  let maxRank = 0;
  let node = -1;
  for (let parent in parents) {
    if (parents[parent].length > 1 || uf.rank[parent] < maxRank) continue;

    let curNode = parents[parent][0];
    if (uf.rank[parent] === maxRank) {
      if (node > curNode) node = curNode;
    } else {
      maxRank = uf.rank[parent];
      node = curNode;
    }
  }

  if (node === -1) return Math.min(...initial);
  return node;
};

console.log(minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1,2]))